<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Voltorb Flip — Enhanced Canvas</title>
<style>
  :root{
    --bg:#111;
    --panel:#0f1720;
    --accent:#ffd166;
    --muted:#94a3b8;
    --tile:#172032;
    --voltorb-red: #ff4d4d;
    --voltorb-dark: #8b0000;
    --tile-1: #3b82f6;
    --tile-2: #f59e0b;
    --tile-3: #10b981;
  }
  html,body{height:100%;}
  body{
    margin:0;
    font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue";
    background:linear-gradient(180deg,#071024 0%, #07182a 60%);
    color:#e6eef6;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:24px;
  }
  .app{
    display:grid;
    grid-template-columns: 420px 1fr;
    gap:20px;
    width:980px;
    max-width:calc(100vw - 48px);
  }
  .panel{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.005));
    border:1px solid rgba(255,255,255,0.04);
    padding:16px;
    border-radius:10px;
    box-shadow: 0 6px 30px rgba(2,6,23,0.6);
  }
  h1{
    margin:4px 0 12px 0; 
    font-size:20px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  h1::before {
    content: "⚡";
    font-size: 24px;
  }
  canvas{background:var(--tile); display:block; border-radius:8px; cursor:pointer;}
  .info{
    display:flex; flex-direction:column; gap:8px;
  }
  .row{
    display:flex; align-items:center; justify-content:space-between;
  }
  .big{
    font-size:20px; font-weight:600;
  }
  .muted{color:var(--muted); font-size:12px;}
  button{
    background:linear-gradient(180deg,var(--accent), #ffb84d);
    border:none; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:600;
    box-shadow: 0 4px 10px rgba(255,185,77,0.12);
    transition: all 0.2s ease;
  }
  button:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 6px 15px rgba(255,185,77,0.2);
  }
  button:disabled{opacity:0.5; cursor:not-allowed;}
  .grid-info{
    display:grid;
    grid-template-columns: repeat(2, 1fr);
    gap:8px; margin-top:12px;
  }
  .clue{
    background:rgba(255,255,255,0.02); padding:8px; border-radius:8px; font-size:13px;
    transition: all 0.2s ease;
  }
  .clue.highlight {
    background: rgba(255, 209, 102, 0.1);
    border: 1px solid rgba(255, 209, 102, 0.3);
  }
  .clues-grid{
    display:grid;
    grid-template-columns: repeat(6, 1fr);
    gap:6px;
    margin-top:10px;
  }
  .clue-cell{ text-align:center; padding:6px; border-radius:6px; background:rgba(255,255,255,0.01); font-size:13px; }
  .clue-head{ font-weight:700; color:var(--muted); font-size:11px; }
  footer{ margin-top:12px; font-size:12px; color:var(--muted); }
  .controls{ display:flex; gap:8px; margin-top:10px; flex-wrap: wrap; }
  .status{ 
    margin-top:8px; 
    font-weight:600; 
    color:#ffdcdc; 
    min-height: 24px;
    transition: all 0.3s ease;
  }
  .status.success { color: #a7f3d0; }
  .status.warning { color: #fde68a; }
  .status.danger { color: #fecaca; }
  
  .score-animation {
    animation: scorePop 0.5s ease;
  }
  
  @keyframes scorePop {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
  }
  
  .tile-flip {
    animation: flipTile 0.4s ease;
  }
  
  @keyframes flipTile {
    0% { transform: rotateY(0deg); }
    50% { transform: rotateY(90deg); }
    100% { transform: rotateY(0deg); }
  }
  
  .voltorb-explosion {
    animation: explode 0.6s ease;
  }
  
  @keyframes explode {
    0% { transform: scale(1); }
    50% { transform: scale(1.3); }
    100% { transform: scale(1); }
  }
  
  .difficulty-selector {
    display: flex;
    gap: 8px;
    margin-top: 12px;
  }
  
  .difficulty-btn {
    flex: 1;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    color: var(--muted);
    padding: 6px;
    border-radius: 6px;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .difficulty-btn.active {
    background: rgba(255,209,102,0.2);
    border-color: var(--accent);
    color: var(--accent);
  }
  
  .stats {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
    margin-top: 12px;
  }
  
  .stat-box {
    background: rgba(255,255,255,0.02);
    padding: 8px;
    border-radius: 6px;
    text-align: center;
  }
  
  .stat-value {
    font-size: 18px;
    font-weight: 600;
  }
  
  .stat-label {
    font-size: 10px;
    color: var(--muted);
  }
  
  @media (max-width:900px){
    .app{grid-template-columns: 1fr; width:100%;}
    .controls { justify-content: center; }
  }
</style>
</head>
<body>
<div class="app">
  <div class="panel" style="display:flex; flex-direction:column; gap:10px;">
    <h1>Voltorb Flip — Enhanced</h1>
    <div class="info">
      <div class="row">
        <div>
          <div class="muted">Total banked score</div>
          <div class="big" id="totalScore">0</div>
        </div>
        <div>
          <div class="muted">Current run multiplier</div>
          <div class="big" id="currentMult">1</div>
        </div>
      </div>

      <div class="stats">
        <div class="stat-box">
          <div class="stat-value" id="gamesPlayed">0</div>
          <div class="stat-label">Games Played</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="bestScore">0</div>
          <div class="stat-label">Best Score</div>
        </div>
      </div>

      <div class="difficulty-selector">
        <div class="difficulty-btn active" data-difficulty="easy">Easy</div>
        <div class="difficulty-btn" data-difficulty="medium">Medium</div>
        <div class="difficulty-btn" data-difficulty="hard">Hard</div>
      </div>

      <div class="row controls">
        <button id="bankBtn">Bank (Collect)</button>
        <button id="newBtn">New Round</button>
        <button id="revealBtn">Reveal Board</button>
      </div>

      <div class="status" id="statusText">Click a tile to flip it.</div>

      <div class="grid-info">
        <div>
          <div class="muted">Row clues (sum / voltorbs)</div>
          <div id="rowClues"></div>
        </div>
        <div>
          <div class="muted">Col clues (sum / voltorbs)</div>
          <div id="colClues"></div>
        </div>
      </div>

      <footer>Rules: flip tiles. 2 doubles, 3 triples current multiplier. Flip a Voltorb and you lose the run. Bank to save multiplier to total score.</footer>
    </div>
  </div>

  <div class="panel" style="display:flex; flex-direction:column; gap:10px; align-items:center;">
    <canvas id="board" width="520" height="520"></canvas>
    <div style="width:100%; display:flex; gap:8px; justify-content:center;">
      <div style="text-align:center;">
        <div class="muted">Tiles flipped</div>
        <div id="flippedCount" class="big">0</div>
      </div>
      <div style="text-align:center;">
        <div class="muted">Remaining tiles</div>
        <div id="remainingCount" class="big">25</div>
      </div>
    </div>
  </div>
</div>

<script>
/*
  Voltorb Flip — Enhanced Canvas implementation
  - 5x5 board
  - Tiles: {value: 0(voltorb)|1|2|3, revealed: bool}
  - Clues: row/column sums + voltorb counts
  - Scoring:
      currentMultiplier starts at 1.
      flipping 2 multiplies by 2, 3 multiplies by 3, 1 leaves multiplier unchanged.
      flipping 0 (Voltorb): run ends with no gain.
      Bank button: add currentMultiplier to totalScore and start new round (if multiplier > 1 or even 1 allowed).
*/

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d', { alpha: false });

// config
const SIZE = 5;
const TILE_GAP = 8;
const PADDING = 20;
const gridSize = Math.min(canvas.width, canvas.height) - 2 * PADDING;
const TILE_SIZE = (gridSize - TILE_GAP * (SIZE - 1)) / SIZE;

// game state
let board = []; // matrix of {value, revealed}
let rowClues = [];
let colClues = [];
let totalScore = 0;
let currentMultiplier = 1;
let flippedTiles = 0;
let roundOver = false;
let gamesPlayed = 0;
let bestScore = 0;
let difficulty = 'easy';

// UI elements
const totalScoreEl = document.getElementById('totalScore');
const currentMultEl = document.getElementById('currentMult');
const statusText = document.getElementById('statusText');
const rowCluesEl = document.getElementById('rowClues');
const colCluesEl = document.getElementById('colClues');
const flippedCountEl = document.getElementById('flippedCount');
const remainingCountEl = document.getElementById('remainingCount');
const bankBtn = document.getElementById('bankBtn');
const newBtn = document.getElementById('newBtn');
const revealBtn = document.getElementById('revealBtn');
const gamesPlayedEl = document.getElementById('gamesPlayed');
const bestScoreEl = document.getElementById('bestScore');
const difficultyBtns = document.querySelectorAll('.difficulty-btn');

// Event listeners
bankBtn.addEventListener('click', () => {
  if (roundOver) { startNewRound(); return; }
  if (currentMultiplier > 0) {
    totalScore += currentMultiplier;
    updateBestScore();
    updateUI();
    statusText.textContent = `Banked ${currentMultiplier}. New round started.`;
    statusText.classList.add('success');
    setTimeout(() => statusText.classList.remove('success'), 2000);
    totalScoreEl.classList.add('score-animation');
    setTimeout(() => totalScoreEl.classList.remove('score-animation'), 500);
  }
  startNewRound();
});

newBtn.addEventListener('click', () => {
  startNewRound();
});

revealBtn.addEventListener('click', () => {
  revealAll();
  render();
});

difficultyBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    difficultyBtns.forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    difficulty = btn.dataset.difficulty;
    startNewRound();
  });
});

canvas.addEventListener('click', (e) => {
  if (roundOver) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left - PADDING;
  const y = e.clientY - rect.top - PADDING;
  if (x < 0 || y < 0) return;
  const col = Math.floor(x / (TILE_SIZE + TILE_GAP));
  const row = Math.floor(y / (TILE_SIZE + TILE_GAP));
  if (row < 0 || row >= SIZE || col < 0 || col >= SIZE) return;
  flipTile(row, col);
  render();
});

// helpers: board generation
function shuffleArray(a){
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function generateBoard(){
  const totalTiles = SIZE * SIZE;
  let voltorbCount, threeCount, twoCount;

  // Set counts based on difficulty
  switch(difficulty) {
    case 'easy':
      voltorbCount = randBetween(5, 7);
      threeCount = randBetween(2, 4);
      twoCount = randBetween(5, 7);
      break;
    case 'medium':
      voltorbCount = randBetween(7, 9);
      threeCount = randBetween(1, 3);
      twoCount = randBetween(4, 6);
      break;
    case 'hard':
      voltorbCount = randBetween(9, 11);
      threeCount = randBetween(1, 2);
      twoCount = randBetween(3, 5);
      break;
    default:
      voltorbCount = randBetween(6, 8);
      threeCount = randBetween(1, 3);
      twoCount = randBetween(4, 6);
  }

  let values = [];
  for(let i=0;i<voltorbCount;i++) values.push(0);
  for(let i=0;i<threeCount;i++) values.push(3);
  for(let i=0;i<twoCount;i++) values.push(2);
  while(values.length < totalTiles) values.push(1);

  shuffleArray(values);

  // fill board matrix
  const mat = [];
  for(let r=0;r<SIZE;r++){
    const row = [];
    for(let c=0;c<SIZE;c++){
      row.push({ value: values[r*SIZE + c], revealed:false });
    }
    mat.push(row);
  }
  return mat;
}

function computeClues(){
  rowClues = [];
  colClues = [];
  for(let r=0;r<SIZE;r++){
    let sum = 0, vol = 0;
    for(let c=0;c<SIZE;c++){
      const v = board[r][c].value;
      if (v === 0) vol++; else sum += v;
    }
    rowClues.push({sum,vol});
  }
  for(let c=0;c<SIZE;c++){
    let sum=0, vol=0;
    for(let r=0;r<SIZE;r++){
      const v = board[r][c].value;
      if (v === 0) vol++; else sum += v;
    }
    colClues.push({sum,vol});
  }
}

function randBetween(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

// game actions
function startNewRound(){
  board = generateBoard();
  computeClues();
  currentMultiplier = 1;
  flippedTiles = 0;
  roundOver = false;
  gamesPlayed++;
  statusText.textContent = "New round — good luck!";
  statusText.className = "status";
  updateUI();
  render();
}

function flipTile(row, col){
  const tile = board[row][col];
  if (!tile || tile.revealed) return;
  
  // Add flip animation
  tile.animating = true;
  setTimeout(() => {
    tile.animating = false;
    render();
  }, 400);
  
  tile.revealed = true;
  flippedTiles++;
  
  if (tile.value === 0){
    // voltorb -> round over and lose current multiplier
    roundOver = true;
    statusText.textContent = "Boom! You hit a Voltorb — run lost. Press Bank to start a new round.";
    statusText.className = "status danger";
    currentMultiplier = 0;
    tile.exploding = true;
    setTimeout(() => {
      tile.exploding = false;
      render();
    }, 600);
    updateUI();
    return;
  } else if (tile.value === 1){
    statusText.textContent = "Revealed a 1 — no change to multiplier.";
    statusText.className = "status";
  } else {
    currentMultiplier *= tile.value;
    statusText.textContent = `Nice! Revealed ${tile.value} — multiplier ×${tile.value}`;
    statusText.className = "status success";
    currentMultEl.classList.add('score-animation');
    setTimeout(() => currentMultEl.classList.remove('score-animation'), 500);
  }
  
  if (flippedTiles === SIZE*SIZE) {
    // all tiles revealed
    roundOver = true;
    statusText.textContent = "All tiles revealed — round over. Bank to collect or start new round.";
    statusText.className = "status success";
  }
  updateUI();
}

function revealAll(){
  for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) board[r][c].revealed = true;
  roundOver = true;
  updateUI();
}

function updateBestScore() {
  if (totalScore > bestScore) {
    bestScore = totalScore;
    bestScoreEl.textContent = bestScore;
    bestScoreEl.classList.add('score-animation');
    setTimeout(() => bestScoreEl.classList.remove('score-animation'), 500);
  }
}

function updateUI() {
  totalScoreEl.textContent = totalScore;
  currentMultEl.textContent = currentMultiplier;
  flippedCountEl.textContent = flippedTiles;
  remainingCountEl.textContent = SIZE*SIZE - flippedTiles;
  gamesPlayedEl.textContent = gamesPlayed;
  bestScoreEl.textContent = bestScore;
  
  // Update clue highlighting
  updateClueHighlighting();
}

function updateClueHighlighting() {
  // Clear previous highlights
  document.querySelectorAll('.clue').forEach(clue => {
    clue.classList.remove('highlight');
  });
  
  // Highlight rows/columns with no voltorbs
  rowClues.forEach((clue, index) => {
    if (clue.vol === 0) {
      const rowClueElements = document.querySelectorAll('#rowClues .clue');
      if (rowClueElements[index]) {
        rowClueElements[index].classList.add('highlight');
      }
    }
  });
  
  colClues.forEach((clue, index) => {
    if (clue.vol === 0) {
      const colClueElements = document.querySelectorAll('#colClues .clue');
      if (colClueElements[index]) {
        colClueElements[index].classList.add('highlight');
      }
    }
  });
}

/* Rendering */
function drawRoundedRect(x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
  ctx.fill();
}

function render(){
  // background
  ctx.fillStyle = '#0b1220';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // draw grid
  for(let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      const x = PADDING + c*(TILE_SIZE + TILE_GAP);
      const y = PADDING + r*(TILE_SIZE + TILE_GAP);
      const tile = board[r][c];
      
      // Apply animation transforms
      if (tile.animating) {
        ctx.save();
        ctx.translate(x + TILE_SIZE/2, y + TILE_SIZE/2);
        ctx.scale(0.1, 1);
        ctx.translate(-(x + TILE_SIZE/2), -(y + TILE_SIZE/2));
      }
      
      if (tile.exploding) {
        ctx.save();
        const scale = 1.3;
        ctx.translate(x + TILE_SIZE/2, y + TILE_SIZE/2);
        ctx.scale(scale, scale);
        ctx.translate(-(x + TILE_SIZE/2), -(y + TILE_SIZE/2));
      }
      
      // tile background
      if (!tile.revealed){
        ctx.fillStyle = '#1b2936';
        drawRoundedRect(x,y,TILE_SIZE,TILE_SIZE,8);
        
        // subtle highlight
        ctx.fillStyle = 'rgba(255,255,255,0.02)';
        ctx.fillRect(x,y+TILE_SIZE-4,TILE_SIZE,4);
        
        // tile number hint (for debugging - remove in production)
        // ctx.fillStyle = 'rgba(255,255,255,0.2)';
        // ctx.font = '12px sans-serif';
        // ctx.textAlign = 'center';
        // ctx.textBaseline = 'middle';
        // ctx.fillText(tile.value, x + TILE_SIZE/2, y + TILE_SIZE/2);
      } else {
        // revealed style depends on value
        if (tile.value === 0){
          ctx.fillStyle = tile.exploding ? '#ff0000' : '#2b1b1b';
          drawRoundedRect(x,y,TILE_SIZE,TILE_SIZE,8);
          
          // draw voltorb (circle)
          ctx.fillStyle = '#ffffff';
          ctx.beginPath();
          ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2 - 6, TILE_SIZE*0.22, 0, Math.PI*2);
          ctx.fill();
          
          ctx.fillStyle = tile.exploding ? '#ffaaaa' : '#d11b1b';
          ctx.beginPath();
          ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2 + 6, TILE_SIZE*0.22, 0, Math.PI*2);
          ctx.fill();
          
          // little cross stroke
          ctx.strokeStyle = 'rgba(0,0,0,0.4)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x+TILE_SIZE*0.22, y+TILE_SIZE*0.22);
          ctx.lineTo(x+TILE_SIZE*0.78, y+TILE_SIZE*0.78);
          ctx.moveTo(x+TILE_SIZE*0.78, y+TILE_SIZE*0.22);
          ctx.lineTo(x+TILE_SIZE*0.22, y+TILE_SIZE*0.78);
          ctx.stroke();
          
          // explosion effect
          if (tile.exploding) {
            ctx.strokeStyle = 'rgba(255,255,255,0.7)';
            ctx.lineWidth = 3;
            for (let i = 0; i < 8; i++) {
              const angle = (i / 8) * Math.PI * 2;
              const length = TILE_SIZE * 0.4;
              ctx.beginPath();
              ctx.moveTo(x + TILE_SIZE/2, y + TILE_SIZE/2);
              ctx.lineTo(
                x + TILE_SIZE/2 + Math.cos(angle) * length,
                y + TILE_SIZE/2 + Math.sin(angle) * length
              );
              ctx.stroke();
            }
          }
        } else {
          // number tile
          const colors = {1: '#3b82f6', 2: '#f59e0b', 3:'#10b981'};
          ctx.fillStyle = '#101827';
          drawRoundedRect(x,y,TILE_SIZE,TILE_SIZE,8);
          
          // big number
          ctx.fillStyle = colors[tile.value] || '#fff';
          ctx.font = `bold ${Math.floor(TILE_SIZE*0.5)}px sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(String(tile.value), x + TILE_SIZE/2, y + TILE_SIZE/2 + 2);
          
          // subtle glow effect for multiplier tiles
          if (tile.value > 1) {
            ctx.shadowColor = colors[tile.value];
            ctx.shadowBlur = 15;
            ctx.fillText(String(tile.value), x + TILE_SIZE/2, y + TILE_SIZE/2 + 2);
            ctx.shadowBlur = 0;
          }
        }
      }

      // tile border
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.lineWidth = 1;
      ctx.strokeRect(x+0.5, y+0.5, TILE_SIZE-1, TILE_SIZE-1);
      
      // Restore transformations
      if (tile.animating || tile.exploding) {
        ctx.restore();
      }
    }
  }

  // draw row & column clues at borders
  // columns at top
  const clueBoxH = 46;
  // top background
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  ctx.fillRect(PADDING, 8, gridSize, clueBoxH);

  // draw column clues
  for(let c=0;c<SIZE;c++){
    const x = PADDING + c*(TILE_SIZE + TILE_GAP);
    const clue = colClues[c];
    drawClueBox(x, 10, TILE_SIZE, 40, clue.sum, clue.vol);
  }
  // left-side row clues
  for(let r=0;r<SIZE;r++){
    const y = PADDING + r*(TILE_SIZE + TILE_GAP);
    const clue = rowClues[r];
    drawLeftClueBox(8, y, 44, TILE_SIZE, clue.sum, clue.vol);
  }

  // UI overlays: hints in DOM
  renderClueDom();
}

function drawClueBox(x,y,w,h,sum,vol){
  // small rounded box with sum and voltorb count
  ctx.fillStyle = 'rgba(255,255,255,0.01)';
  ctx.beginPath();
  ctx.roundRect = ctx.roundRect || function(x,y,w,h,r){ // fallback if missing
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
  };
  // try modern rounded rect if available
  if (ctx.roundRect) {
    ctx.beginPath();
    ctx.roundRect(x, y, w, h, 8);
    ctx.fill();
  } else {
    drawRoundedRect(x, y, w, h, 8);
  }

  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(sum, x + w/2, y + 16);

  ctx.fillStyle = vol > 0 ? 'rgba(255,77,77,0.8)' : 'rgba(255,255,255,0.45)';
  ctx.font = '11px sans-serif';
  ctx.fillText(vol + ' V', x + w/2, y + 30);
}

function drawLeftClueBox(x,y,w,h,sum,vol){
  ctx.fillStyle = 'rgba(255,255,255,0.01)';
  drawRoundedRect(x,y,w,h,8);
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(sum, x + w/2, y + 18);

  ctx.fillStyle = vol > 0 ? 'rgba(255,77,77,0.8)' : 'rgba(255,255,255,0.45)';
  ctx.font = '11px sans-serif';
  ctx.fillText(vol + ' V', x + w/2, y + 34);
}

function renderClueDom(){
  // produce row clue DOM
  rowCluesEl.innerHTML = '';
  colCluesEl.innerHTML = '';

  rowClues.forEach((cl, i) => {
    const el = document.createElement('div');
    el.className = 'clue';
    el.style.marginTop = (i? '6px':'6px');
    el.textContent = `Row ${i+1}: sum ${cl.sum} — ${cl.vol} Voltorb(s)`;
    rowCluesEl.appendChild(el);
  });
  colClues.forEach((cl, i) => {
    const el = document.createElement('div');
    el.className = 'clue';
    el.style.marginTop = (i? '6px':'6px');
    el.textContent = `Col ${i+1}: sum ${cl.sum} — ${cl.vol} Voltorb(s)`;
    colCluesEl.appendChild(el);
  });
  
  updateClueHighlighting();
}

// Initialize the game
startNewRound();
</script>
</body>
</html>